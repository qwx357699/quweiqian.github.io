(window.webpackJsonp=window.webpackJsonp||[]).push([[290],{659:function(v,_,e){"use strict";e.r(_);var o=e(10),t=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"生命周期详解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生命周期详解"}},[v._v("#")]),v._v(" 生命周期详解")]),v._v(" "),_("blockquote",[_("p",[v._v("面试题："),_("code",[v._v("new Vue")]),v._v("之后，发生了什么？数据改变后，又发生了什么？")])]),v._v(" "),_("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://mdrs.yuanjin.tech/img/20210302155735.png",alt:"image-20210302155735758"}}),v._v(" "),_("ol",[_("li",[_("p",[v._v("创建vue实例和创建组件的流程基本一致")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("首先做一些初始化的操作，主要是设置一些私有属性到实例中")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("运行生命周期钩子函数"),_("code",[v._v("beforeCreate")])])])]),v._v(" "),_("li",[_("p",[v._v("进入注入流程：处理属性、computed、methods、data、provide、inject，最后使用代理模式将它们挂载到实例中")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("运行生命周期钩子函数"),_("code",[v._v("created")])])])]),v._v(" "),_("li",[_("p",[v._v("生成"),_("code",[v._v("render")]),v._v("函数：如果有配置，直接使用配置的"),_("code",[v._v("render")]),v._v("，如果没有，使用运行时编译器，把模板编译为"),_("code",[v._v("render")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("运行生命周期钩子函数"),_("code",[v._v("beforeMount")])])])]),v._v(" "),_("li",[_("p",[v._v("创建一个"),_("code",[v._v("Watcher")]),v._v("，传入一个函数"),_("code",[v._v("updateComponent")]),v._v("，该函数会运行"),_("code",[v._v("render")]),v._v("，把得到的"),_("code",[v._v("vnode")]),v._v("再传入"),_("code",[v._v("_update")]),v._v("函数执行。")]),v._v(" "),_("p",[v._v("在执行"),_("code",[v._v("render")]),v._v("函数的过程中，会收集所有依赖，将来依赖变化时会重新运行"),_("code",[v._v("updateComponent")]),v._v("函数")]),v._v(" "),_("p",[v._v("在执行"),_("code",[v._v("_update")]),v._v("函数的过程中，触发"),_("code",[v._v("patch")]),v._v("函数，由于目前没有旧树，因此直接为当前的虚拟dom树的每一个普通节点生成elm属性，即真实dom。")]),v._v(" "),_("p",[v._v("如果遇到创建一个组件的vnode，则会进入组件实例化流程，该流程和创建vue实例流程基本相同，最终会把创建好的组件实例挂载vnode的"),_("code",[v._v("componentInstance")]),v._v("属性中，以便复用。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("运行生命周期钩子函数"),_("code",[v._v("mounted")])])])])])]),v._v(" "),_("li",[_("p",[v._v("重渲染？")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("数据变化后，所有依赖该数据的"),_("code",[v._v("Watcher")]),v._v("均会重新运行，这里仅考虑"),_("code",[v._v("updateComponent")]),v._v("函数对应的"),_("code",[v._v("Watcher")])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("Watcher")]),v._v("会被调度器放到"),_("code",[v._v("nextTick")]),v._v("中运行，也就是微队列中，这样是为了避免多个依赖的数据同时改变后被多次执行")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("运行生命周期钩子函数"),_("code",[v._v("beforeUpdate")])])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("updateComponent")]),v._v("函数重新执行")]),v._v(" "),_("p",[v._v("在执行"),_("code",[v._v("render")]),v._v("函数的过程中，会去掉之前的依赖，重新收集所有依赖，将来依赖变化时会重新运行"),_("code",[v._v("updateComponent")]),v._v("函数")]),v._v(" "),_("p",[v._v("在执行"),_("code",[v._v("_update")]),v._v("函数的过程中，触发"),_("code",[v._v("patch")]),v._v("函数。")]),v._v(" "),_("p",[v._v("新旧两棵树进行对比。")]),v._v(" "),_("p",[v._v("普通"),_("code",[v._v("html")]),v._v("节点的对比会导致真实节点被创建、删除、移动、更新")]),v._v(" "),_("p",[v._v("组件节点的对比会导致组件被创建、删除、移动、更新")]),v._v(" "),_("p",[v._v("当新组件需要创建时，进入实例化流程")]),v._v(" "),_("p",[v._v("当旧组件需要删除时，会调用旧组件的"),_("code",[v._v("$destroy")]),v._v("方法删除组件，该方法会先触发"),_("strong",[v._v("生命周期钩子函数"),_("code",[v._v("beforeDestroy")])]),v._v("，然后递归调用子组件的"),_("code",[v._v("$destroy")]),v._v("方法，然后触发"),_("strong",[v._v("生命周期钩子函数"),_("code",[v._v("destroyed")])])]),v._v(" "),_("p",[v._v("当组件属性更新时，相当于组件的"),_("code",[v._v("updateComponent")]),v._v("函数被重新触发执行，进入重渲染流程，和本节相同。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("运行生命周期钩子函数"),_("code",[v._v("updated")])])])])])])]),v._v(" "),_("p",[v._v("​")]),v._v(" "),_("p",[v._v("​")])])}),[],!1,null,null,null);_.default=t.exports}}]);