(window.webpackJsonp=window.webpackJsonp||[]).push([[386],{759:function(t,a,s){"use strict";s.r(a);var r=s(10),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"类-构造函数的语法糖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类-构造函数的语法糖"}},[t._v("#")]),t._v(" 类：构造函数的语法糖")]),t._v(" "),a("h2",{attrs:{id:"传统的构造函数的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传统的构造函数的问题"}},[t._v("#")]),t._v(" 传统的构造函数的问题")]),t._v(" "),a("ol",[a("li",[t._v("属性和原型方法定义分离，降低了可读性")]),t._v(" "),a("li",[t._v("原型成员可以被枚举")]),t._v(" "),a("li",[t._v("默认情况下，构造函数仍然可以被当作普通函数使用")])]),t._v(" "),a("h2",{attrs:{id:"类的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的特点"}},[t._v("#")]),t._v(" 类的特点")]),t._v(" "),a("ol",[a("li",[t._v("类声明不会被提升，与 let 和 const 一样，存在暂时性死区")]),t._v(" "),a("li",[t._v("类中的所有代码均在严格模式下执行")]),t._v(" "),a("li",[t._v("类的所有方法都是不可枚举的")]),t._v(" "),a("li",[t._v("类的所有方法都无法被当作构造函数使用")]),t._v(" "),a("li",[t._v("类的构造器必须使用 new 来调用")])])])}),[],!1,null,null,null);a.default=v.exports}}]);