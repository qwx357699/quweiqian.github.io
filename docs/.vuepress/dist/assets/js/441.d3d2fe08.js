(window.webpackJsonp=window.webpackJsonp||[]).push([[441],{813:function(t,v,_){"use strict";_.r(v);var a=_(10),n=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"比较运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#比较运算符"}},[t._v("#")]),t._v(" 比较运算符")]),t._v(" "),v("p",[t._v("大小比较：>   <    >=    <=\n相等比较：==   !=   ===   !==")]),t._v(" "),v("p",[v("strong",[t._v("比较运算符的返回类型：boolean")])]),t._v(" "),v("p",[v("strong",[t._v("算术运算符的优先级高于比较运算符")])]),t._v(" "),v("h2",{attrs:{id:"大小比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#大小比较"}},[t._v("#")]),t._v(" 大小比较")]),t._v(" "),v("h3",{attrs:{id:"细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#细节"}},[t._v("#")]),t._v(" 细节")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("两个字符串比较大小，比较的是字符串的字符编码。")])]),t._v(" "),v("li",[v("p",[t._v("如果一个不是字符串，并且两个都是原始类型，将它们都转换为数字进行比较")])])]),t._v(" "),v("p",[t._v("'1' -> 1\n'' -> 0\n'   ' -> 0\n'  a' -> NaN\n'3.14' -> 3.14")]),t._v(" "),v("p",[t._v("NaN与任何数字比较，得到的结果都是false")]),t._v(" "),v("p",[t._v("Infinity比任何数字都大")]),t._v(" "),v("p",[t._v("-Infinity比任何数字都小")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("如果其中一个是对象，将对象转换为原始类型然后，按照规则1或规则2进行比较")])]),t._v(" "),v("p",[t._v('目前，对象转换为原始类型后，是字符串 "[object Object]"')]),t._v(" "),v("h2",{attrs:{id:"相等比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相等比较"}},[t._v("#")]),t._v(" 相等比较")]),t._v(" "),v("h3",{attrs:{id:"和-相等比较-和-不相等比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#和-相等比较-和-不相等比较"}},[t._v("#")]),t._v(" == 和 != (相等比较 和 不相等比较)")]),t._v(" "),v("p",[t._v("==: 比较两个数据是否相等\n!=: 比较两个数据是否不相等")]),t._v(" "),v("p",[v("strong",[t._v("细节")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("两端的类型相同，直接比较两个数据本身是否相同（两个对象比较的地址）")])]),t._v(" "),v("li",[v("p",[t._v("两端的类型不同")])])]),t._v(" "),v("p",[t._v("1). null 和 undefined， 它们之间相等， 和其他原始类型比较， 则不相等。\n2). 其他原始类型，比较时先转换为数字，再进行比较\n3). NaN与任何数字比较，都是false，包括自身\n4). Infinity和-Infinity，自能和自身相等\n5). 对象比较时，要先转换为原始类型后，再进行比较")]),t._v(" "),v("p",[v("strong",[t._v("由于相等和不相等比较，对于不同类型的数据比较违反直觉，因此，通常我们不适用这种比较方式，而是使用更加接近直觉的严格相等和严格不相等比较")])]),t._v(" "),v("h3",{attrs:{id:"和-严格相等-和-严格不相等"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#和-严格相等-和-严格不相等"}},[t._v("#")]),t._v(" === 和 !== （严格相等 和 严格不相等）")]),t._v(" "),v("p",[t._v("=== ： 两端的数据和类型必须相同\n!== ： 两端的数据或类型不相同")]),t._v(" "),v("ol",[v("li",[t._v("两端类型相同，规则和相等比较一致。")]),t._v(" "),v("li",[t._v("两端类型不同，为false。")])]),t._v(" "),v("p",[t._v("数字规则：")]),t._v(" "),v("p",[t._v("1). NaN与任何数字比较，都是false，包括自身\n2). Infinity和-Infinity，自能和自身相等")])])}),[],!1,null,null,null);v.default=n.exports}}]);