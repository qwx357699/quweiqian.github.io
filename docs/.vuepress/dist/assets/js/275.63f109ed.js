(window.webpackJsonp=window.webpackJsonp||[]).push([[275],{641:function(v,a,t){"use strict";t.r(a);var e=t(10),_=Object(e.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[v._v("#")]),v._v(" 优化")]),v._v(" "),a("h2",{attrs:{id:"使用key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用key"}},[v._v("#")]),v._v(" 使用key")]),v._v(" "),a("p",[v._v("对于通过循环生成的列表，应给每个列表项一个稳定且唯一的key，这有利于在列表变动时，尽量少的删除、新增、改动元素")]),v._v(" "),a("h2",{attrs:{id:"使用冻结的对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用冻结的对象"}},[v._v("#")]),v._v(" 使用冻结的对象")]),v._v(" "),a("p",[v._v("冻结的对象不会被响应化")]),v._v(" "),a("h2",{attrs:{id:"使用函数式组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用函数式组件"}},[v._v("#")]),v._v(" 使用函数式组件")]),v._v(" "),a("p",[v._v("参见"),a("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6",target:"_blank",rel:"noopener noreferrer"}},[v._v("函数式组件"),a("OutboundLink")],1)]),v._v(" "),a("h2",{attrs:{id:"使用计算属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用计算属性"}},[v._v("#")]),v._v(" 使用计算属性")]),v._v(" "),a("p",[v._v("如果模板中某个数据会使用多次，并且该数据是通过计算得到的，使用计算属性以缓存它们")]),v._v(" "),a("h2",{attrs:{id:"非实时绑定的表单项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非实时绑定的表单项"}},[v._v("#")]),v._v(" 非实时绑定的表单项")]),v._v(" "),a("p",[v._v("当使用"),a("code",[v._v("v-model")]),v._v("绑定一个表单项时，当用户改变表单项的状态时，也会随之改变数据，从而导致"),a("code",[v._v("vue")]),v._v("发生重渲染（"),a("code",[v._v("rerender")]),v._v("），这会带来一些性能的开销。")]),v._v(" "),a("p",[v._v("特别是当用户改变表单项时，页面有一些动画正在进行中，由于JS执行线程和浏览器渲染线程是互斥的，最终会导致动画出现卡顿。")]),v._v(" "),a("p",[v._v("我们可以通过使用"),a("code",[v._v("lazy")]),v._v("或不使用"),a("code",[v._v("v-model")]),v._v("的方式解决该问题，但要注意，这样可能会导致在某一个时间段内数据和表单项的值是不一致的。")]),v._v(" "),a("h2",{attrs:{id:"保持对象引用稳定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保持对象引用稳定"}},[v._v("#")]),v._v(" 保持对象引用稳定")]),v._v(" "),a("p",[v._v("在绝大部分情况下，"),a("code",[v._v("vue")]),v._v("触发"),a("code",[v._v("rerender")]),v._v("的时机是其依赖的数据发生"),a("strong",[v._v("变化")])]),v._v(" "),a("p",[v._v("若数据没有发生变化，哪怕给数据重新赋值了，"),a("code",[v._v("vue")]),v._v("也是不会做出任何处理的")]),v._v(" "),a("p",[v._v("下面是"),a("code",[v._v("vue")]),v._v("判断数据"),a("strong",[v._v("没有变化")]),v._v("的源码")]),v._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// value 为旧值， newVal 为新值")]),v._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("if")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("newVal "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("===")]),v._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("||")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("newVal "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("!==")]),v._v(" newVal "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("&&")]),v._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("!==")]),v._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("return")]),v._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),a("p",[v._v("因此，如果需要，只要能保证组件的依赖数据不发生变化，组件就不会重新渲染。")]),v._v(" "),a("p",[v._v("对于原始数据类型，保持其值不变即可")]),v._v(" "),a("p",[v._v("对于对象类型，保持其引用不变即可")]),v._v(" "),a("p",[v._v("从另一方面来说，由于可以通过保持属性引用稳定来避免子组件的重渲染，那么我们应该细分组件来尽量避免多余的渲染")]),v._v(" "),a("h2",{attrs:{id:"使用v-show替代v-if"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用v-show替代v-if"}},[v._v("#")]),v._v(" 使用v-show替代v-if")]),v._v(" "),a("p",[v._v("对于频繁切换显示状态的元素，使用v-show可以保证虚拟dom树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量dom元素的节点，这一点极其重要")]),v._v(" "),a("p",[v._v("关键字：频繁切换显示状态、内部包含大量dom元素")]),v._v(" "),a("h2",{attrs:{id:"使用延迟装载-defer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用延迟装载-defer"}},[v._v("#")]),v._v(" 使用延迟装载（defer）")]),v._v(" "),a("p",[v._v("首页白屏时间主要受到两个因素的影响：")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("打包体积过大")]),v._v(" "),a("p",[v._v("巨型包需要消耗大量的传输时间，导致JS传输完成前页面只有一个"),a("code",[v._v("<div>")]),v._v("，没有可显示的内容")])]),v._v(" "),a("li",[a("p",[v._v("需要立即渲染的内容太多")]),v._v(" "),a("p",[v._v("JS传输完成后，浏览器开始执行JS构造页面。")]),v._v(" "),a("p",[v._v("但可能一开始要渲染的组件太多，不仅JS执行的时间很长，而且执行完后浏览器要渲染的元素过多，从而导致页面白屏")])])]),v._v(" "),a("p",[v._v("打包体积过大需要自行优化打包体积，本节不予讨论")]),v._v(" "),a("p",[v._v("本节仅讨论渲染内容太多的问题。")]),v._v(" "),a("p",[v._v("一个可行的办法就是"),a("strong",[v._v("延迟装载组件")]),v._v("，让组件按照指定的先后顺序依次一个一个渲染出来")]),v._v(" "),a("blockquote",[a("p",[v._v("延迟装载是一个思路，本质上就是利用"),a("code",[v._v("requestAnimationFrame")]),v._v("事件分批渲染内容，它的具体实现多种多样")])]),v._v(" "),a("h2",{attrs:{id:"使用keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用keep-alive"}},[v._v("#")]),v._v(" 使用keep-alive")]),v._v(" "),a("p",[v._v("后续讲解")]),v._v(" "),a("h2",{attrs:{id:"长列表优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#长列表优化"}},[v._v("#")]),v._v(" 长列表优化")]),v._v(" "),a("p",[v._v("后续讲解")])])}),[],!1,null,null,null);a.default=_.exports}}]);