(window.webpackJsonp=window.webpackJsonp||[]).push([[367],{751:function(n,t,a){"use strict";a.r(t);var r=a(10),s=Object(r.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"扩展-类型化数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展-类型化数组"}},[n._v("#")]),n._v(" [扩展]类型化数组")]),n._v(" "),t("h2",{attrs:{id:"数字存储的前置知识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字存储的前置知识"}},[n._v("#")]),n._v(" 数字存储的前置知识")]),n._v(" "),t("ol",[t("li",[t("p",[t("strong",[n._v("计算机必须使用固定的位数来存储数字，无论存储的数字是大是小，在内存中占用的空间是固定的。")])]),n._v(" "),t("blockquote",[t("p",[t("em",[n._v("为什么是固定的位数存储数字呢？和计算机组成原理甚至和编译原理有关，计算机读取数据是一块一块读的，每一块是没有分割的，不固定就不知道在哪分割。这样导致有很多种存储方案，8位16位32位等")])])])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("n位的无符号整数能表示的数字是2^n个，取值范围是：0 ~ 2^n - 1")])])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("n位的有符号整数能表示的数字是2^n个，取值范围是：-2^(n-1) ~ 2^(n-1) - 1")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("计算机对数字存储的是 补码！\n规定正数的源码、反码、补码是相同的，负数不一样\n负数第一位为 1，正数为 0\n3 位有符号整数源码：\n000 001 010 011 100 101 110 111 -4~3\n--- 正数 ---\n+0 000 反码：000 补码：000 \n+1 001 反码：001 补码：001\n+2 010 反码：010 补码：010\n+3 011 反码：011 补码：011\n--- 负数 ---\n-0 100 反码：111 补码：1000 多一位丢丢弃 补码：000 +0、-0的补码相同\n-1 101 反码：110 补码：111\n-2 110 反码：101 补码：110\n-3 111 反码：100 补码：101\n--- -0重复 ---\n(-1) + (-3)=-4\n= 源码：101 + 源码：111\n= 补码：111 + 补码：101\n= 补码：100 溢出的1舍去，补码和-0一样，所以使用-0表示-4，\n所以-4没有源码和反码，在3位有符号整数中。\n因此只要补码是 100 ，其十进制数值就位-1。\n参考：https://zhuanlan.zhihu.com/p/371184302\n")])])])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("浮点数表示法可以用于表示整数和小数，目前分为两种标准：")])]),n._v(" "),t("ol",[t("li",[t("strong",[n._v("32位浮点数：又称为单精度浮点数，它用1位表示符号，8位表示阶码，23位表示尾数")])]),n._v(" "),t("li",[t("strong",[n._v("64位浮点数：又称为双精度浮点数，它用1位表示符号，11位表示阶码，52位表示尾数")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("浮点数表示中，任何一个数字变为科学计数法表示：\n1.aaaaa * 10^n \n精度(有效数字)：aaaaa 底数：10 指数：n \n其中变化的只有 精度 和 指数\n计算机怎么存储的呢，例如\nxxxx xxxx xxxx xxxx\n第一位最为符号位 0或1\n中间拿一部作为指数，这部分称为阶码\n剩下的储存尾数，就是有效数字 aaaaa\n也就是按照 符号+阶码+尾数 方式存储\n具体表示32位，64位，这两种都是国际标准，一般计算机语言会选择一种，有的语言两种方式都有：\n32位浮点数：符号(1)+阶码(8)+尾数(23)\n64位浮点数：符号(1)+阶码(11)+尾数(52)\n有效数字：\n333.1  4个有效数字\n1.2353453 8个有效数字\n小知识：其他语言里面有效数字超过7位，使用双精度(64位浮点数)，低于7位使用32位浮点数。\n")])])])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("JS中的所有数字，均使用双精度浮点数保存")])]),n._v(" "),t("blockquote",[t("p",[t("em",[n._v("小数、整数、0都是用64位浮点数存储的")])])])])]),n._v(" "),t("h2",{attrs:{id:"类型化数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型化数组"}},[n._v("#")]),n._v(" 类型化数组")]),n._v(" "),t("blockquote",[t("p",[t("em",[n._v("为什么需要类型化数组？")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("假设要存储 100 个 0\n需要占用 6400 位 \n1byte =8bit \n1kb =1024byte\n1mb = 1024kb\nbyte 是计算机存储的最小单位\n意味着需要 800kb 内存\n在某些场景下面，我们特别需要在意内存空间的使用\n传统的数组方式会造成特别大的内存空间的浪费\n为了解决这个问题，js 推出来类型化数组\n")])])]),t("p",[n._v("**类型化数组：用于优化多个数字的存储(**"),t("em",[n._v("注意类型化数组只针对数字的数组，不能存在对象、布尔、字符串等类型数组")]),n._v(")")]),n._v(" "),t("p",[t("strong",[n._v("具体分为：")])]),n._v(" "),t("ul",[t("li",[t("strong",[n._v("Int8Array： 8位有符号整数（-128 ~ 127）")])]),n._v(" "),t("li",[t("strong",[n._v("Uint8Array： 8位无符号整数（0 ~ 255）")])]),n._v(" "),t("li",[t("strong",[n._v("Int16Array: ...")])]),n._v(" "),t("li",[t("strong",[n._v("Uint16Array: ...")])]),n._v(" "),t("li",[t("strong",[n._v("Int32Array: ...")])]),n._v(" "),t("li",[t("strong",[n._v("Uint32Array: ...")])]),n._v(" "),t("li",[t("strong",[n._v("Float32Array:")])]),n._v(" "),t("li",[t("strong",[n._v("Float64Array")])])]),n._v(" "),t("ol",[t("li",[t("strong",[n._v("如何创建数组")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//1. const arr = new Int8Array(10)\nnew 数组构造函数(长度)\n\n//2. const arr = Int8Array.of(2,3,4)\n数组构造函数.of(元素...)\n// 注意：防止溢出\n// 例如: const arr = Int8Array.of(128,3,4)\n// 输出: [-128, 3, 4, buffer: ArrayBuffer(3)...]\n// 为什么是 -128?因为最大存储+127，\n// +127 补码：0111 1111\n// +128 补码：1000 0000 直接存储，8位够， 1000 0000 -0 也就表示-128\n// 如果: const arr = Int8Array.of(-129)会得到什么？\n// -129 源码：1 1000 0001 反码：1 0111 1110 补码：1 0111 1111，存储，8位不够，丢弃高位1，存储 0111 1111 也就是+127\n\n//3. const arr = Int8Array.from([2,3,4])\n数组构造函数.from(可迭代对象)\n\n//4. const arr = Int8Array.of(2, 5, 5, 9);\n//   const arr2 = new Int8Array(arr);\nnew 数组构造函数(其他类型化数组)\n\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[n._v("得到长度")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("数组.length   //得到元素数量\n数组.byteLength //得到占用内存的字节数\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[t("strong",[n._v("其他的用法跟普通数组一致，但是：")])])]),n._v(" "),t("ul",[t("li",[t("strong",[n._v("不能增加和删除数据，类型化数组的长度固定")])]),n._v(" "),t("li",[t("strong",[n._v("一些返回数组的方法，返回的数组是同类型化的新数组")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);