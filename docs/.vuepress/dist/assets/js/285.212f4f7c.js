(window.webpackJsonp=window.webpackJsonp||[]).push([[285],{654:function(v,e,o){"use strict";o.r(e);var _=o(10),t=Object(_.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"虚拟dom详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom详解"}},[v._v("#")]),v._v(" 虚拟DOM详解")]),v._v(" "),e("blockquote",[e("p",[v._v("面试题：请你阐述一下对vue虚拟dom的理解")])]),v._v(" "),e("h2",{attrs:{id:"什么是虚拟dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟dom"}},[v._v("#")]),v._v(" 什么是虚拟dom？")]),v._v(" "),e("p",[v._v("虚拟dom本质上就是一个普通的JS对象，用于描述视图的界面结构")]),v._v(" "),e("p",[v._v("在vue中，每个组件都有一个"),e("code",[v._v("render")]),v._v("函数，每个"),e("code",[v._v("render")]),v._v("函数都会返回一个虚拟dom树，这也就意味着每个组件都对应一棵虚拟DOM树")]),v._v(" "),e("img",{staticStyle:{zoom:"30%"},attrs:{src:"http://mdrs.yuanjin.tech/img/20210225140726.png",alt:"image-20210225140726003"}}),v._v(" "),e("h2",{attrs:{id:"为什么需要虚拟dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要虚拟dom"}},[v._v("#")]),v._v(" 为什么需要虚拟dom？")]),v._v(" "),e("p",[v._v("在"),e("code",[v._v("vue")]),v._v("中，渲染视图会调用"),e("code",[v._v("render")]),v._v("函数，这种渲染不仅发生在组件创建时，同时发生在视图依赖的数据更新时。如果在渲染时，直接使用真实"),e("code",[v._v("DOM")]),v._v("，由于真实"),e("code",[v._v("DOM")]),v._v("的创建、更新、插入等操作会带来大量的性能损耗，从而就会极大的降低渲染效率。")]),v._v(" "),e("p",[v._v("因此，"),e("code",[v._v("vue")]),v._v("在渲染时，使用虚拟dom来替代真实dom，主要为解决渲染效率的问题。")]),v._v(" "),e("blockquote",[e("p",[v._v("在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。\t\t\t\t--- 祖师爷")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://www.zhihu.com/question/31809713",target:"_blank",rel:"noopener noreferrer"}},[v._v("(7 封私信) 网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？ - 知乎 (zhihu.com)"),e("OutboundLink")],1)])]),v._v(" "),e("h2",{attrs:{id:"虚拟dom是如何转换为真实dom的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom是如何转换为真实dom的"}},[v._v("#")]),v._v(" 虚拟dom是如何转换为真实dom的？")]),v._v(" "),e("p",[v._v("在一个组件实例首次被渲染时，它先生成虚拟dom树，然后根据虚拟dom树创建真实dom，并把真实dom挂载到页面中合适的位置，此时，每个虚拟dom便会对应一个真实的dom。")]),v._v(" "),e("p",[v._v("如果一个组件受响应式数据变化的影响，需要重新渲染时，它仍然会重新调用render函数，创建出一个新的虚拟dom树，用新树和旧树对比，通过对比，vue会找到最小更新量，然后更新必要的虚拟dom节点，最后，这些更新过的虚拟节点，会去修改它们对应的真实dom")]),v._v(" "),e("p",[v._v("这样一来，就保证了对真实dom达到最小的改动。")]),v._v(" "),e("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://mdrs.yuanjin.tech/img/20210225144108.png",alt:"image-20210225144108143"}}),v._v(" "),e("blockquote",[e("p",[e("strong",[v._v("实际上是直接使用新树，抛弃旧树，然后只更新必要的真实 dom，详见第5节课。")])])]),v._v(" "),e("h2",{attrs:{id:"模板和虚拟dom的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模板和虚拟dom的关系"}},[v._v("#")]),v._v(" 模板和虚拟dom的关系")]),v._v(" "),e("p",[v._v("vue框架中有一个"),e("code",[v._v("compile")]),v._v("模块，它主要负责将模板转换为"),e("code",[v._v("render")]),v._v("函数，而"),e("code",[v._v("render")]),v._v("函数调用后将得到虚拟dom。")]),v._v(" "),e("p",[v._v("编译的过程分两步：")]),v._v(" "),e("ol",[e("li",[v._v("将模板字符串转换成为"),e("code",[v._v("AST")])]),v._v(" "),e("li",[v._v("将"),e("code",[v._v("AST")]),v._v("转换为"),e("code",[v._v("render")]),v._v("函数")])]),v._v(" "),e("p",[v._v("如果使用传统的引入方式，则编译时间发生在组件第一次加载时，这称之为运行时编译。")]),v._v(" "),e("p",[v._v("如果是在"),e("code",[v._v("vue-cli")]),v._v("的默认配置下，编译发生在打包时，这称之为模板预编译。")]),v._v(" "),e("p",[v._v("编译是一个极其耗费性能的操作，预编译可以有效的提高运行时的性能，而且，由于运行的时候已不需要编译，"),e("code",[v._v("vue-cli")]),v._v("在打包时会排除掉"),e("code",[v._v("vue")]),v._v("中的"),e("code",[v._v("compile")]),v._v("模块，以减少打包体积")]),v._v(" "),e("p",[v._v("模板的存在，仅仅是为了让开发人员更加方便的书写界面代码")]),v._v(" "),e("p",[e("strong",[v._v("vue最终运行的时候，最终需要的是render函数，而不是模板，因此，模板中的各种语法，在虚拟dom中都是不存在的，它们都会变成虚拟dom的配置")])])])}),[],!1,null,null,null);e.default=t.exports}}]);