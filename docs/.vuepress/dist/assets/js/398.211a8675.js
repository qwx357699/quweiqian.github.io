(window.webpackJsonp=window.webpackJsonp||[]).push([[398],{774:function(e,t,v){"use strict";v.r(t);var _=v(10),i=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"基本使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本使用"}},[e._v("#")]),e._v(" 基本使用")]),e._v(" "),t("blockquote",[t("p",[e._v("请求测试地址：http://study.yuanjin.tech/api/local")])]),e._v(" "),t("p",[e._v("使用 "),t("code",[e._v("fetch")]),e._v(" 函数即可立即向服务器发送网络请求")]),e._v(" "),t("h2",{attrs:{id:"参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[e._v("#")]),e._v(" 参数")]),e._v(" "),t("p",[e._v("该函数有两个参数：")]),e._v(" "),t("ol",[t("li",[e._v("必填，字符串，请求地址")]),e._v(" "),t("li",[e._v("选填，对象，请求配置")])]),e._v(" "),t("p",[t("strong",[e._v("请求配置对象")])]),e._v(" "),t("ul",[t("li",[e._v("method：字符串，请求方法，默认值 GET")]),e._v(" "),t("li",[e._v("headers：对象，请求头信息")]),e._v(" "),t("li",[e._v("body: 请求体的内容，必须匹配请求头中的 Content-Type")]),e._v(" "),t("li",[e._v("mode：字符串，请求模式\n"),t("ul",[t("li",[e._v("cors：默认值，配置为该值，会在请求头中加入 origin 和 referer")]),e._v(" "),t("li",[e._v("no-cors：配置为该值，不会在请求头中加入 origin 和 referer，跨域的时候可能会出现问题")]),e._v(" "),t("li",[e._v("same-origin：指示请求必须在同一个域中发生，如果请求其他域，则会报错")])])]),e._v(" "),t("li",[e._v("credentials: 如何携带凭据（cookie）\n"),t("ul",[t("li",[e._v("omit：默认值，不携带 cookie")]),e._v(" "),t("li",[e._v("same-origin：请求同源地址时携带 cookie")]),e._v(" "),t("li",[e._v("include：请求任何地址都携带 cookie")])])]),e._v(" "),t("li",[e._v("cache：配置缓存模式\n"),t("ul",[t("li",[e._v("default: 表示 fetch 请求之前将检查下 http 的缓存.")]),e._v(" "),t("li",[e._v("no-store: 表示 fetch 请求将完全忽略 http 缓存的存在. 这意味着请求之前将不再检查下 http 的缓存, 拿到响应后, 它也不会更新 http 缓存.")]),e._v(" "),t("li",[e._v("no-cache: 如果存在缓存, 那么 fetch 将发送一个条件查询 request 和一个正常的 request, 拿到响应后, 它会更新 http 缓存.")]),e._v(" "),t("li",[e._v("reload: 表示 fetch 请求之前将忽略 http 缓存的存在, 但是请求拿到响应后, 它将主动更新 http 缓存.")]),e._v(" "),t("li",[e._v("force-cache: 表示 fetch 请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的 request.")]),e._v(" "),t("li",[e._v("only-if-cached: 表示 fetch 请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在 mode 为”same-origin”时有效).")])])])]),e._v(" "),t("h2",{attrs:{id:"返回值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#返回值"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),t("p",[e._v("fetch 函数返回一个 Promise 对象")]),e._v(" "),t("ul",[t("li",[e._v("当收到服务器的返回结果后，Promise 进入 resolved 状态，状态数据为 Response 对象")]),e._v(" "),t("li",[e._v("当网络发生错误（或其他导致无法完成交互的错误）时，Promise 进入 rejected 状态，状态数据为错误信息")])]),e._v(" "),t("p",[t("strong",[e._v("Response 对象")])]),e._v(" "),t("ul",[t("li",[e._v("ok：boolean，当响应消息码在 200~299 之间时为 true，其他为 false")]),e._v(" "),t("li",[e._v("status：number，响应的状态码")]),e._v(" "),t("li",[e._v("text()：用于处理文本格式的 Ajax 响应。它从响应中获取文本流，将其读完，然后返回一个被解决为 string 对象的 Promise。")]),e._v(" "),t("li",[e._v("blob()：用于处理二进制文件格式（比如图片或者电子表格）的 Ajax 响应。它读取文件的原始数据，一旦读取完整个文件，就返回一个被解决为 blob 对象的 Promise。")]),e._v(" "),t("li",[e._v("json()：用于处理 JSON 格式的 Ajax 的响应。它将 JSON 数据流转换为一个被解决为 JavaScript 对象的 promise。")]),e._v(" "),t("li",[e._v("redirect()：可以用于重定向到另一个 URL。它会创建一个新的 Promise，以解决来自重定向的 URL 的响应。")])])])}),[],!1,null,null,null);t.default=i.exports}}]);