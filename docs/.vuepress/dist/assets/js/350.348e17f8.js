(window.webpackJsonp=window.webpackJsonp||[]).push([[350],{717:function(t,v,_){"use strict";_.r(v);var l=_(10),e=Object(l.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"普通符号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#普通符号"}},[t._v("#")]),t._v(" 普通符号")]),t._v(" "),v("p",[t._v("符号是ES6新增的一个数据类型，它通过使用函数 "),v("code",[t._v("Symbol(符号描述)")]),t._v(" 来创建")]),t._v(" "),v("p",[t._v("符号设计的初衷，是为了给对象设置私有属性")]),t._v(" "),v("p",[t._v("私有属性：只能在对象内部使用，外面无法使用")]),t._v(" "),v("p",[t._v("符号具有以下特点：")]),t._v(" "),v("ul",[v("li",[t._v("没有字面量")]),t._v(" "),v("li",[t._v("使用 typeof 得到的类型是 symbol")]),t._v(" "),v("li",[v("strong",[t._v("每次调用 Symbol 函数得到的符号永远不相等，无论符号名是否相同")])]),t._v(" "),v("li",[t._v("符号可以作为对象的属性名存在，这种属性称之为符号属性\n"),v("ul",[v("li",[t._v("开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问")]),t._v(" "),v("li",[t._v("符号属性是不能枚举的，因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性")]),t._v(" "),v("li",[t._v("Object.getOwnPropertyNames 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性")]),t._v(" "),v("li",[t._v("ES6 新增 Object.getOwnPropertySymbols 方法，可以读取符号")])])]),t._v(" "),v("li",[t._v("符号无法被隐式转换，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但符号可以显式的转换为字符串，通过 String 构造函数进行转换即可，console.log 之所以可以输出符号，是它在内部进行了显式转换")])])])}),[],!1,null,null,null);v.default=e.exports}}]);