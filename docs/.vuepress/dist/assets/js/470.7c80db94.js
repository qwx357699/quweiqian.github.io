(window.webpackJsonp=window.webpackJsonp||[]).push([[470],{841:function(p,n,a){"use strict";a.r(n);var t=a(10),v=Object(t.a)({},(function(){var p=this,n=p._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":p.$parent.slotKey}},[n("h1",{attrs:{id:"pnpm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm"}},[p._v("#")]),p._v(" pnpm")]),p._v(" "),n("p",[p._v("pnpm是一种新起的包管理器，从npm的下载量看，目前还没有超过yarn，但它的实现方式值得主流包管理器学习，某些开发者极力推荐使用pnpm")]),p._v(" "),n("p",[p._v("从结果上来看，它具有以下优势：")]),p._v(" "),n("ol",[n("li",[n("p",[p._v("目前，安装效率高于npm和yarn的最新版")])]),p._v(" "),n("li",[n("p",[p._v("极其简洁的node_modules目录")])]),p._v(" "),n("li",[n("p",[p._v("避免了开发时使用间接依赖的问题")]),p._v(" "),n("blockquote",[n("p",[n("em",[p._v("意思是没安装包，但是其他的包依赖中有，直接使用，这个现象(间接依赖)开发者和包的开发者有犯过这样问题。可能依赖的包下次更新时换了依赖，或者版本大升级了，导致之前功能不能使用了，npm，yarn1.x对包进行扁平式管理，就会出现这样的问题。")])])])]),p._v(" "),n("li",[n("p",[p._v("能极大的降低磁盘空间的占用")])])]),p._v(" "),n("h2",{attrs:{id:"安装和使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装和使用"}},[p._v("#")]),p._v(" 安装和使用")]),p._v(" "),n("p",[p._v("全局安装pnpm")]),p._v(" "),n("div",{staticClass:"language-shell extra-class"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[n("span",{pre:!0,attrs:{class:"token function"}},[p._v("npm")]),p._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[p._v("install")]),p._v(" "),n("span",{pre:!0,attrs:{class:"token parameter variable"}},[p._v("-g")]),p._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[p._v("pnpm")]),p._v("\n")])])]),n("p",[p._v("之后在使用时，只需要把npm替换为pnpm即可")]),p._v(" "),n("p",[p._v("如果要执行安装在本地的CLI，可以使用pnpx，它和 npx 的功能完全一样，唯一不同的是，在使用pnpx执行一个需要安装的命令时，会使用pnpm进行安装")]),p._v(" "),n("blockquote",[n("p",[p._v("比如 "),n("code",[p._v("npx mocha")]),p._v("执行本地的 "),n("code",[p._v("mocha")]),p._v("命令时，如果 "),n("code",[p._v("mocha")]),p._v("没有安装，则npx会自动的、临时的安装mocha，安装好后，自动运行mocha命令")])]),p._v(" "),n("h2",{attrs:{id:"pnpm原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm原理"}},[p._v("#")]),p._v(" pnpm原理")]),p._v(" "),n("ol",[n("li",[n("p",[p._v("同 yarn 和 npm 一样，pnpm 仍然使用缓存来保存已经安装过的包，以及使用 pnpm-lock.yaml 来记录详细的依赖版本")]),p._v(" "),n("blockquote",[n("p",[n("em",[p._v("yarn和npm都存在一个问题，虽然都使用了缓存，但是每次安装时候，还是从缓存拷贝文件，依然会造成磁盘空间浪费，而且拷贝也是很耗时")])])])]),p._v(" "),n("li",[n("p",[p._v("不同于 yarn 和 npm， pnpm 使用"),n("strong",[p._v("符号链接和硬链接")]),p._v("（可将它们想象成快捷方式）的做法来放置依赖，从而规避了从缓存中拷贝文件的时间，使得安装和卸载的速度更快")]),p._v(" "),n("blockquote",[n("p",[n("em",[p._v("pnpm做法是下载包后放到根目录的.pnpm-store文件夹下，然后工程中可以简单理解成创建了一个快捷方式，这种方式是建立连接，不是拷贝，这样节省了空间，安装卸载都很快。")])])])]),p._v(" "),n("li",[n("p",[p._v("由于使用了"),n("strong",[p._v("符号链接和硬链接")]),p._v("，pnpm可以规避windows操作系统路径过长的问题，因此，它选择使用树形的依赖结果，有着几乎完美的依赖管理。也因为如此，项目中只能使用直接依赖，而不能使用间接依赖")])])]),p._v(" "),n("h2",{attrs:{id:"注意事项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[p._v("#")]),p._v(" 注意事项")]),p._v(" "),n("p",[p._v("由于 pnpm 会改动 node_modules 目录结构，使得每个包只能使用直接依赖，而不能使用间接依赖，因此，如果使用 pnpm 安装的包中包含间接依赖，则会出现问题("),n("strong",[p._v("现在不会了，除非使用了绝对路径")]),p._v(")")]),p._v(" "),n("p",[p._v("由于 pnpm 超高的安装卸载效率，越来越多的包开始修正之前的间接依赖代码")])])}),[],!1,null,null,null);n.default=v.exports}}]);