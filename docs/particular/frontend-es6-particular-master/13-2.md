# [扩展]类型化数组

## 数字存储的前置知识

1. **计算机必须使用固定的位数来存储数字，无论存储的数字是大是小，在内存中占用的空间是固定的。**

   > *为什么是固定的位数存储数字呢？和计算机组成原理甚至和编译原理有关，计算机读取数据是一块一块读的，每一块是没有分割的，不固定就不知道在哪分割。这样导致有很多种存储方案，8位16位32位等*
   >
2. **n位的无符号整数能表示的数字是2^n个，取值范围是：0 ~ 2^n - 1**
3. **n位的有符号整数能表示的数字是2^n个，取值范围是：-2^(n-1) ~ 2^(n-1) - 1**

   ```
   计算机对数字存储的是 补码！
   规定正数的源码、反码、补码是相同的，负数不一样
   负数第一位为 1，正数为 0
   3 位有符号整数源码：
   000 001 010 011 100 101 110 111 -4~3
   --- 正数 ---
   +0 000 反码：000 补码：000 
   +1 001 反码：001 补码：001
   +2 010 反码：010 补码：010
   +3 011 反码：011 补码：011
   --- 负数 ---
   -0 100 反码：111 补码：1000 多一位丢丢弃 补码：000 +0、-0的补码相同
   -1 101 反码：110 补码：111
   -2 110 反码：101 补码：110
   -3 111 反码：100 补码：101
   --- -0重复 ---
   (-1) + (-3)=-4
   = 源码：101 + 源码：111
   = 补码：111 + 补码：101
   = 补码：100 溢出的1舍去，补码和-0一样，所以使用-0表示-4，
   所以-4没有源码和反码，在3位有符号整数中。
   因此只要补码是 100 ，其十进制数值就位-1。
   参考：https://zhuanlan.zhihu.com/p/371184302
   ```

4. **浮点数表示法可以用于表示整数和小数，目前分为两种标准：**

   1. **32位浮点数：又称为单精度浮点数，它用1位表示符号，8位表示阶码，23位表示尾数**
   2. **64位浮点数：又称为双精度浮点数，它用1位表示符号，11位表示阶码，52位表示尾数**

   ```
   浮点数表示中，任何一个数字变为科学计数法表示：
   1.aaaaa * 10^n 
   精度(有效数字)：aaaaa 底数：10 指数：n 
   其中变化的只有 精度 和 指数
   计算机怎么存储的呢，例如
   xxxx xxxx xxxx xxxx
   第一位最为符号位 0或1
   中间拿一部作为指数，这部分称为阶码
   剩下的储存尾数，就是有效数字 aaaaa
   也就是按照 符号+阶码+尾数 方式存储
   具体表示32位，64位，这两种都是国际标准，一般计算机语言会选择一种，有的语言两种方式都有：
   32位浮点数：符号(1)+阶码(8)+尾数(23)
   64位浮点数：符号(1)+阶码(11)+尾数(52)
   有效数字：
   333.1  4个有效数字
   1.2353453 8个有效数字
   小知识：其他语言里面有效数字超过7位，使用双精度(64位浮点数)，低于7位使用32位浮点数。
   ```

5. **JS中的所有数字，均使用双精度浮点数保存**

   > *小数、整数、0都是用64位浮点数存储的*
   >

## 类型化数组

> *为什么需要类型化数组？*

```
假设要存储 100 个 0
需要占用 6400 位 
1byte =8bit 
1kb =1024byte
1mb = 1024kb
byte 是计算机存储的最小单位
意味着需要 800kb 内存
在某些场景下面，我们特别需要在意内存空间的使用
传统的数组方式会造成特别大的内存空间的浪费
为了解决这个问题，js 推出来类型化数组
```

**类型化数组：用于优化多个数字的存储(***注意类型化数组只针对数字的数组，不能存在对象、布尔、字符串等类型数组*)

**具体分为：**

* **Int8Array： 8位有符号整数（-128 ~ 127）**
* **Uint8Array： 8位无符号整数（0 ~ 255）**
* **Int16Array: ...**
* **Uint16Array: ...**
* **Int32Array: ...**
* **Uint32Array: ...**
* **Float32Array:**
* **Float64Array**

1. **如何创建数组**

```
//1. const arr = new Int8Array(10)
new 数组构造函数(长度)

//2. const arr = Int8Array.of(2,3,4)
数组构造函数.of(元素...)
// 注意：防止溢出
// 例如: const arr = Int8Array.of(128,3,4)
// 输出: [-128, 3, 4, buffer: ArrayBuffer(3)...]
// 为什么是 -128?因为最大存储+127，
// +127 补码：0111 1111
// +128 补码：1000 0000 直接存储，8位够， 1000 0000 -0 也就表示-128
// 如果: const arr = Int8Array.of(-129)会得到什么？
// -129 源码：1 1000 0001 反码：1 0111 1110 补码：1 0111 1111，存储，8位不够，丢弃高位1，存储 0111 1111 也就是+127

//3. const arr = Int8Array.from([2,3,4])
数组构造函数.from(可迭代对象)

//4. const arr = Int8Array.of(2, 5, 5, 9);
//   const arr2 = new Int8Array(arr);
new 数组构造函数(其他类型化数组)

```

2. **得到长度**

```
数组.length   //得到元素数量
数组.byteLength //得到占用内存的字节数
```

3. **其他的用法跟普通数组一致，但是：**

* **不能增加和删除数据，类型化数组的长度固定**
* **一些返回数组的方法，返回的数组是同类型化的新数组**
