# loader

> webpack做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。
> 更多的功能需要借助webpack loaders和webpack plugins完成。

webpack loader： loader本质上是一个函数，它的作用是将某个源码字符串转换成另一个源码字符串返回。

![](https://qwq9527.gitee.io/resource/imgs/2020-01-13-10-39-24.png)

loader函数的将在模块解析的过程中被调用，以得到最终的源码。

## **全流程：**

![](https://qwq9527.gitee.io/resource/imgs/2020-01-13-09-28-52.png)

## **chunk中解析模块的流程：**

![](https://qwq9527.gitee.io/resource/imgs/2020-01-13-09-29-08.png)

## **chunk中解析模块的更详细流程：**

![](https://qwq9527.gitee.io/resource/imgs/2020-01-13-09-35-44.png)

## **处理loaders流程：**

![](https://qwq9527.gitee.io/resource/imgs/2020-01-13-10-29-54.png)

## **loader配置：**

## **完整配置**

```js
module.exports = {
    module: { //针对模块的配置，目前版本只有两个配置，rules、noParse
        rules: [ //模块匹配规则，可以存在多个规则
            { //每个规则是一个对象
                test: /\.js$/, //匹配的模块正则
                use: [ //匹配到后应用的规则模块
                    {  //其中一个规则
                        loader: "模块路径", //loader模块的路径，该字符串会被放置到require中
                        options: { //向对应loader传递的额外参数

                        }
                    }
                ]
            }
        ]
    }
}
```

## **简化配置**

```js
module.exports = {
    module: { //针对模块的配置，目前版本只有两个配置，rules、noParse
        rules: [ //模块匹配规则，可以存在多个规则
            { //每个规则是一个对象
                test: /\.js$/, //匹配的模块正则
                use: ["模块路径1", "模块路径2"]//loader模块的路径，该字符串会被放置到require中
            }
        ]
    }
}
```

## **补充**：

1. **loader 参数**

   参数配置，除了在配置中使用 options 方式外还可以使用 `?xxx=xxx` query形式。

   ```js
    {
        test: /index\.js$/,
            use: [
                {
                    loader:"./loaders/test-loader?changeVar=let"
                   // loader: "./loaders/test-loader",
                   // options: {
                   //    changeVar: "let",
                   // },
                },
            ],
    },
   ```

   

2. **参数获取**

   loader 函数运行时会绑定到一个全局上下文 this 中，通过 `this.loaders` 看到 loader 中配置的参数，比较麻烦，通过 loader-utils 插件来获取传入的 options

   ```js
   module.exports = function (sourceCode) {
       //sourceCode : 变量 a = 1;
       console.log("test-loader运行了", this);
       var options = loaderUtils.getOptions(this);
       console.log(options);
       var reg = new RegExp(options.changeVar, "g");
       return sourceCode.replace(reg, "var");
   };
   ```


3. **loader 执行顺序**

   ```js
   module: {
           rules: [
               {
                   test: /index\.js$/, //正则表达式，匹配模块的路径
                   use: ["./loaders/loader1", "./loaders/loader2"] //匹配到了之后，使用哪些加载器
               }, //规则1
               {
                   test: /\.js$/, //正则表达式，匹配模块的路径
                   use: ["./loaders/loader3", "./loaders/loader4"] //匹配到了之后，使用哪些加载器
               } //规则2
           ], //模块的匹配规则
       }
   ```

   执行结果是 **loader4 loader3 loader2 loader1**。

   为什么? 

   读取配置文件匹配时是从上往下的，匹配到了将 loader 依次放到一个空数组中，继续读取。

   执行时，从后面往前读。

