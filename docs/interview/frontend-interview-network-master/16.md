# TCP协议

解决可靠传输的问题

![image-20211008163417521](http://mdrs.yuanjin.tech/img/20211008163417.png)

![image-20211008163458168](http://mdrs.yuanjin.tech/img/20211008163458.png)

## TCP收发数据流程

<img src="http://mdrs.yuanjin.tech/img/20211021122224.png" alt="image-20211021122224411" style="zoom:50%;" />

- 收发数据两边都是双向的，不一定像http那样必须是客户端到服务端，服务端到客户端也可以

- 收发数据可以是任意类型，图片文本字符串等

- 收发数据时间可以是几秒钟，也可以是几天，也可以传一部分，等几小时再传，都是可以的

  > 总之，任何时间、任何的方式（数据类型）、任何方向来发送和接收数据都是可以的。
  >
  > 譬如，客户端给服务端发1个，服务端可以给客户端发好几个都是可以的

## TCP如何收发数据

### 分段发送

<img src="http://mdrs.yuanjin.tech/img/20211021123315.png" alt="image-20211021123309261" style="zoom:50%;" />

------

*补充：*

只需要了解两个点即可。

发送的数据有可能很短，也有可能很长，譬如几十万字的小说，需要分段发送，如果网络原因导致数据丢失，造成数据错误等，只需发送错误的那一段即可。

1.  **怎么分段**

**将完整的数据按照字节编号**,一个字节一个字节的进行编号，编号第一位的数字不一定是1，是个随机的数字，不需要管。然后再取出一部分数据，一段一段的发送，一次取几个数据？这个我们不care。

总之，数据很少可能一次就发送出去，如果数据比较大进行编号，分段发送。

2. **分段的头部**

前面提到，每层之间传递消息，都要加头，这里是 ***传输层*** 到 ***网络层***。那么这个头在哪里加的呢？

假设现在发送 *1-2* 这段，发完后再发*3-4*这段，不管发送的具体是啥，需要在当前 *1-2* 这部分加上头，发完后，若没问题，再发 *3-4* 部分同样都要加上头

> 1byte=8bit
>
> 1kb=1024byte
>
> 1mb=1024kb

------

### 可靠传输

在TCP协议中，任何时候、任何一方都可以主动发送数据给另一方

为了解决数据报丢失、数据报错乱等问题，TCP协议要求：**接收方收到数据报后，必须对数据报进行确认！**

<img src="http://mdrs.yuanjin.tech/img/20211021124852.png" alt="image-20211021124852569" style="zoom:50%;" />

- seq：表示这次数据报的序号
- ACK：表示这次数据报是一个确认数据报
- ack：表示期望下一次接收的数据报序号

**发送方如果长时间没有收到确认数据报（ACK=1），则会判定丢失或者是错误，然后重发**

------

*补充：*

*为什么要可靠传输？因为以前环境很差,现在网络环境好多了，甚至某些企业和组织讨论方案”关于现在真的需要可靠传输吗“，没有4G的时候，网速特别慢，容易出现丢包，或者传输中不知道啥情况，可能无线电干扰，一些乱七八糟的原因，导致信号错位，1变成0,0变成1。那么可靠传输就是解决数据的丢失和错误的问题*

> 数据报：就是一个传输入单元，比如上图 *1-2* 这两个字节，加上头变成一个单元，就是一个数据报

数据报头部含有一些信息：seq，ACK，ack

- seq：数据报的序号，数据报中第一个字节占总的数据字节中的第几个，作为数据报的序号

- ACK(确认)：接收方必须确认数据，确认数据时要给发送方带去两个信息，ACK 和 ack，上图第一个箭头发送数据，没写 ACK = 0。

  **确认 ACK(ACKnowlegment)		仅当 ACK=1 时确认号字段才有效果。当 ACK=0 时确认号无效。TCP 规定，在链接建立后所有的传送报文段都必须把 ACK 置 1。**	

- ack 途中 ack = x + 1 表示 x 之前的都收到了，期待 下一个的报文

  > 这里给的例子有点问题，ack 计算应该是 ack = x + 数据报中数据字节长度
  >
  > 比如：B 正确的收到 A 发送过来的一个报文段，其序号（seq）字段值是 501，而数据长度是 200 字节（序号 501 ~ 700），表明 B 正确收到 A 发送的到序号 700 位置的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 **701**。
  >
  > <a :href="$withBase('/pdf/【谢希仁】计算机网络第五版.pdf')">见【谢希仁】计算机网络第五版.pdf 194页</a>

------

## 连接的建立（三次握手）

TCP协议要实现数据的收发，必须要先建立连接

连接的本质其实就是双方各自开辟的一块儿内存空间，空间中主要是数据缓冲区和一些变量

<img src="http://mdrs.yuanjin.tech/img/20211021125708.png" alt="image-20211021125708143" style="zoom:50%;"  />

**连接建立的过程需要经过三次数据报传输，因此称之为三次握手**

> 开始
>
> 客户端：我说话能听见吗？
>
> 服务器：能听见，我说话能听见吗？
>
> 客户端：能听见
>
> 结束

<img src="http://mdrs.yuanjin.tech/img/20211021131710.png" alt="image-20211021131710197" style="zoom:50%;"  />

------

*补充：*

这里只关心 SYN=1表示要建立链接，ACK=1表示接受建立链接，seq=x 表示数据序号，能带些数据过去，例如空字符串。

但是【谢希仁】计算机网络第五版 提到：TCP 规定，SYN 报文段（即 SYN =1 的报文段）不能携带数据，但要消耗掉一个序号（seq）。seq 是数据的编号，如果消耗，数据传输不完整，个人猜测这里的序号可能是数据按字节生成的序号外的一些序号。

**同步 SYN(synchronization)		在链接建立时用来同步序号。**当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1 。因此，SYN 置为 1 就表示这是一个连接请求或连接接受报文。

第三次握手，TCP的标准规定，ACK 报文可以携带数据。但**如果不携带数据就不消耗序号**，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。

------



## 连接的销毁（四次挥手）

> 开始
>
> 客户端：我说完了，挂了？
>
> 服务器：我明白你说完了，但别忙挂，我还有话要说。
>
> 服务器继续说......
>
> 服务器：我也说完了，挂了？
>
> 客户端：好的！
>
> 结束

<img src="http://mdrs.yuanjin.tech/img/20211021143028.png" alt="image-20211021143028167" style="zoom:50%;" />

------

**补充**

进入到 **TIME-WAIT**（时间等待）状态。请注意，现在 TCP 连接还没有释放掉。

必须经过**时间等待计时器(TIME-WAIT timer)**设置的时间 **2MSL** 后，才进入到 CLOSED 状态。时间 **MSL** 叫做

**最长报文段寿命（Maximum Segment Lifetime）**，RFC 793 建议设为 2 分钟。但这完全是从工程上来考虑，对于现在的网络，**MSL = 2** 分钟可能太长了一些。因此 TCP 允许不同的实现可根据具体情况使用更小的 MSL 值。因此，从A进入到 TIME-WAIT 状态后，要经过 4 分钟才能进入到 CLOSED 状态，才能开始建立下一个新的连接。当 A 撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。

------



## HTTP和TCP的关系

<img src="http://mdrs.yuanjin.tech/img/20211021134242.png" alt="image-20211021134242311" style="zoom:50%;" />

HTTP协议是对内容格式的规定，它**使用**了TCP协议完成消息的可靠传输

在具体使用TCP协议时：

1. 客户端发消息给服务器叫做请求，服务器发消息给客户端叫做响应

2. 使用HTTP协议的服务器不会主动发消息给客户端（尽管TCP可以），只对请求进行响应

3. 每一个HTTP请求-响应，都要先建立TCP连接（三次握手），然后完成请求-响应后，再销毁连接（四次挥手）。这就导致每次请求-响应都是相互独立的，无法保持状态。

   > 1. 好比 TCP 函数调用 HTTP函数 一样，将 HTTP 格式传走
   > 2. 为什么不用长链接？每链接一次都会开辟空间，请求会造成消耗大量资源

## 面试题

1. 简述 TCP 连接的过程（淘系）

   > 参考答案：
   >
   > TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：
   >
   > 首先服务器进入监听状态，然后即可处理连接
   >
   > 第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。
   >
   > 第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。
   >
   > 第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。
   >
   > 最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成

2. 谈谈你对 TCP 三次握手和四次挥手的理解

   > TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：
   >
   > 首先服务器进入监听状态，然后即可处理连接
   >
   > 第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。
   >
   > 第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。
   >
   > 第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。
   >
   > 最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成
   >
   > 当需要关闭连接时，需要进行四次挥手才能关闭
   >
   > 1. Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。
   > 2. Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。
   > 3. Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。
   > 4. Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。
   > 5. Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。
   > 6. Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。

